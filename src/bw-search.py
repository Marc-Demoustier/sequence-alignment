import argparse

def parse_arguments():
    """
    Parse all the arguments we need for this function

        Returns:
            args: a dict like with all the arguments parsed
    """
    parser = argparse.ArgumentParser(description='search subsequence in a genome following the burrows wheeler '
                                                    'transform')
    parser.add_argument('infile', action='store', help='path to the index file generated by bw-build')
    parser.add_argument('q', action='store', help='sequence to search')
    parser.add_argument('--count-only', help='show only the correspondance number', action='store_true', dest='count')
    return parser.parse_args()


def decompress_sequence(bw):
    """
    Decompress a compressed Burrow Wheeler Transform sequence and returns it

        Parameters:
            bw (string): compressed Burrow Wheeler Transform in bytes string

        Returns:
            bw_decode (string): the decompressed Burrow Wheeler Transform sequence (still with the potential additional
            A and without the $)
    """
    compress_dict = {
        0b00: 'A',
        0b01: 'C',
        0b10: 'G',
        0b11: 'T'
    }

    bw_decode = ''

    for binary in bw:
        # each byte is decomposed in 4 char
        for _ in range(4):
            bw_decode += compress_dict[binary & 0b11]
            binary = binary >> 2

    return bw_decode


def read_infile(infile):
    """
    Read the input file and returns the Burrow Wheeler Transform

        Parameters:
            infile (string): path to the input file

        Returns:
            bw (string): the Burrow Wheeler Transform string
    """
    with open(infile, 'rb') as input_file:
        c, n, p, _ = [int(x) for x in input_file.readline().split()]
        input_file.readline()
        bw = input_file.readline()

    if c:
        bw_decode = decompress_sequence(bw)
        # add the $ in the string and remove the optional additional A
        bw = bw_decode[:n] + '$' + bw_decode[n:len(bw_decode) - p]
    else:
        bw = bw.decode('ascii')

    return bw


def inverse_burrow_wheeler_transform(bw):
    """
    Create the suffix array from the Burrow Wheeler Transform

        Parameters:
            bw (string): The Burrow Wheeler Transform string

        Returns:
            table (array of strings): The suffix array (array with all the rotation of the sequence)
    """
    table = [''] * len(bw)
    for _ in range(len(bw)):
        table = sorted(bw[i] + table[i] for i in range(len(bw)))

    return table


def occurence(c, sup, table):
    """
    Count the occurence of a character c in the last column of the suffix array (limited by sup) and returns it

        Parameters:
            c (char): the character we have to count the occurence
            sup (int): we count the character c only between 0 and sup
            table (array of strings): the suffix array
    """
    occ = 0
    for i in range(sup):
        if table[i][-1] == c:
            occ += 1

    return occ


def create_character_dict(table):
    """
    Create a character dict with each character (key) and the first index where they appear (value). We use also and
    array for the indexes (because a dict is not ordered by default)

        Parameters:
            table (array of strings): the suffix array

        Returns:
            C (dict): link a character to an index in the char_indexes array
            char_indexes (int array): first appearance index of each character in the suffix array
    """
    C = {}
    char_indexes = []
    index = 0

    for i in range(len(table)):
        if table[i][0] not in C:
            C[table[i][0]] = index
            char_indexes.append(i)
            index += 1

    # append a last index to have length of the string (last appearance of the last character in the dict)
    char_indexes.append(i)

    return C, char_indexes


def search_born(table, q):
    """
    Search the bornes such as every strings between these two bornes start with sequence q

        Parameters:
            table (array of strings): the suffix array
            q (string): the sequence to search

        Returns:
            sp (int): first index of a string starting by q
            ep (int): last index + 1 of a string starting by q
    """
    C, char_indexes = create_character_dict(table)

    p = len(q) - 1
    c = q[p]
    i = p
    sp = char_indexes[C[c]] + 1
    ep = char_indexes[C[c] + 1]

    while sp <= ep and i >= 1:
        c = q[i - 1]
        sp = char_indexes[C[c]] + 1 + occurence(c, sp - 1, table)
        ep = char_indexes[C[c]] + occurence(c, ep, table)
        i -= 1
    return sp - 1, ep


def bw_search():
    """
    Search a sequence in an input file and print the index where it appears
    """
    args = parse_arguments()
    bw = read_infile(args.infile)
    table = inverse_burrow_wheeler_transform(bw)
    sp, ep = search_born(table, args.q)

    if args.count:
        # print only the numbers of index found
        print(ep - sp)
    else:
        # print each indexes
        for line in table[sp:ep]:
            print(len(line) - line.index('$') - 1)


if __name__ == "__main__":
    bw_search()