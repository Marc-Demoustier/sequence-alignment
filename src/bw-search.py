import argparse

def parse_arguments():
    parser = argparse.ArgumentParser(description='search subsequence in a genome following the burrows wheeler '
                                                    'transform')
    parser.add_argument('infile', action='store', help='path to the index file generated by bw-build')
    parser.add_argument('q', action='store', help='sequence to search')
    parser.add_argument('--count-only', help='show only the correspondance number', action='store_true', dest='count')
    return parser.parse_args()


def decompress_sequence(bw):
    compress_dict = {
        0b00: 'A',
        0b01: 'C',
        0b10: 'G',
        0b11: 'T'
    }

    bw_decode = ''

    for binary in bw:
        for _ in range(4):
            bw_decode += compress_dict[binary & 0b11]
            binary = binary >> 2

    return bw_decode


def read_infile(infile):
    with open(infile, 'rb') as input_file:
        c, n, p, _ = [int(x) for x in input_file.readline().split()]
        input_file.readline()
        bw = input_file.readline()

    if c:
        bw_decode = decompress_sequence(bw)
        bw = bw_decode[:n] + '$' + bw_decode[n:len(bw_decode) - p]
    else:
        bw = bw.decode('ascii')

    return bw


def inverse_burrow_wheeler_transform(bw):
    table = [''] * len(bw)
    for _ in range(len(bw)):
        table = sorted(bw[i] + table[i] for i in range(len(bw)))

    return table


def occurence(c, sup, table):
    occ = 0
    for i in range(sup):
        if table[i][-1] == c:
            occ += 1

    return occ


def create_character_dict(table):
    C = {}
    char_indexes = []
    index = 0

    for i in range(len(table)):
        if table[i][0] not in C:
            C[table[i][0]] = index
            char_indexes.append(i)
            index += 1

    char_indexes.append(i)

    return C, char_indexes


def search_born(table, q):
    C, char_indexes = create_character_dict(table)

    p = len(q) - 1
    c = q[p]
    i = p
    sp = char_indexes[C[c]] + 1
    ep = char_indexes[C[c] + 1]

    while sp <= ep and i >= 1:
        c = q[i - 1]
        sp = char_indexes[C[c]] + 1 + occurence(c, sp - 1, table)
        ep = char_indexes[C[c]] + occurence(c, ep, table)
        i -= 1
    return sp - 1, ep


def bw_search():
    args = parse_arguments()
    bw = read_infile(args.infile)
    table = inverse_burrow_wheeler_transform(bw)
    sp, ep = search_born(table, args.q)

    if args.count:
        print(ep - sp)
    else:
        for line in table[sp:ep]:
            print(len(line) - line.index('$') - 1)


if __name__ == "__main__":
    bw_search()